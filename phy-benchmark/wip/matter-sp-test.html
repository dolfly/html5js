<html>

<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../base/style.css">
    <script src="../base/boot.js"></script>
    <script src="../base/stats.min.js"></script>
    <title>matter-sp.js test</title>
    <script src="matter-sp.min.js"></script>
</head>

<body>
    <canvas id="stage"></canvas>
    <script>
    var Config = {
        timeScale: 1 / 1000,
        gravity: 9.8 * 0.1,
        positionIterations: 8, // 3,
        velocityIterations: 8, // 8,

        angularVelocity: 0.2,
        boardWidth: 400,
        boardHeight: 10,
        circleRaius: 30,
        circleMargin: 120,
        boxSize: 8,

        // allowSleep: true,
        // warmStarting: true,
        // continuousPhysics: true,
        // subStepping: false,
        // blockSolve: true,
    };

    var tumblerBox;

    var engine;

    function init() {
        engine = Matter.Engine.create({
            positionIterations: Config.positionIterations,
            velocityIterations: Config.velocityIterations,
            world: Matter.World.create({
                gravity: {
                    y: Config.gravity,
                },
            })
        });
        world = engine.world;

        var bw = Config.boardWidth;
        var bh = Config.boardHeight;

        tumblerBox = Matter.Body.create({
            parts: [
                Matter.Bodies.rectangle(WIDTH / 2, HEIGHT / 2 - bw / 2, bw, bh),
                Matter.Bodies.rectangle(WIDTH / 2, HEIGHT / 2 + bw / 2, bw, bh),
                Matter.Bodies.rectangle(WIDTH / 2 - bw / 2, HEIGHT / 2, bh, bw),
                Matter.Bodies.rectangle(WIDTH / 2 + bw / 2, HEIGHT / 2, bh, bw),

                Matter.Bodies.circle(WIDTH / 2 - Config.circleMargin, HEIGHT / 2 - Config.circleMargin, Config.circleRaius),
                Matter.Bodies.circle(WIDTH / 2 + Config.circleMargin, HEIGHT / 2 - Config.circleMargin, Config.circleRaius),
                Matter.Bodies.circle(WIDTH / 2 + Config.circleMargin, HEIGHT / 2 + Config.circleMargin, Config.circleRaius),
                Matter.Bodies.circle(WIDTH / 2 - Config.circleMargin, HEIGHT / 2 + Config.circleMargin, Config.circleRaius),
            ],
            isStatic: true
        });
        Matter.World.add(world, tumblerBox);


        var count = 0;
        var i = 0;
        while (count < COUNT) {
            var body = Matter.Bodies.rectangle(
                WIDTH / 2 + randomInt(-120, 120),
                HEIGHT / 2 + randomInt(-120, 120),
                Config.boxSize,
                Config.boxSize);

            Matter.Body.set(body, 'mass', 1);
            Matter.World.add(world, body);

            count++;
        }

        tick()
    }

    function drawBody(ctx, body) {
        var parts = body.parts;
        parts.forEach(function(part) {
            if (part.circleRadius) {
                drawCircle(ctx, part.circleRadius, part.position.x, part.position.y);
            } else {
                drawPoly(ctx, part.vertices, part.vertices.length);
            }
        });
    }

    function render(ctx, timeStep) {
        ctx.clearRect(0, 0, WIDTH, HEIGHT);

        ctx.lineWidth = 1;

        world.bodies.forEach(function(body) {
            drawBody(ctx, body);
        })
    }

    var angle = 0;

    var runner = Matter.Runner.create();
    runner.isFixed = true;
    runner.delta = 5;

    function update(timeStep) {
        timeStep *= Config.timeScale;

        Matter.Runner.tick(runner, engine);

        angle -= Config.angularVelocity * timeStep;
        Matter.Body.setAngle(tumblerBox, angle);
    }
    </script>
</body>

</html>
